
GitHub Link: https://github.com/anuvabanwasi/apcompsci/tree/master/noogly


Background:

I wanted to work on an independent project that incorporates most of the concepts we learned in APCS - Java Swing, Data Structures, Object Oriented Programming in Java, Exceptions, Logic, Recursion,
Strings, Arrays, Lists, HashMaps, File IO among other topics in Java. A boolean search application encompasses almost all the concepts that was covered in APCS and I was able to work on the concepts that 
comes together in one application.

Overview:

Noogly is a boolean search application. It indexes files and allows users to search the index for any boolean query that uses OR, AND, NOT and combinations of the same. It also supports the use of 
parenthesis for more sophisticated boolean queries. Noogly properly supports precedence (NOT, AND, OR in that order) of boolean operators while it computes the results using negation (not), conjunction 
(and), disjunction (or). The precedence of the operators can be changed using paranthesis.

Usage:

Download jar file from https://github.com/anuvabanwasi/apcompsci/blob/master/noogly/noogly.jar and double click on the jar file to run the application. 
( Use a computer that has Java Runtime Environment or download JRE from here, http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html )

Here are the key components of the project:

1) A program that builds an index (takes text files as input and generates a mapping of words to the text files that the words are present)
2) An application that uses boolean operators (or, and, not) to query the index built in step 1) above and output the name of the relevant text files. For example if the word "sea" appears in file
1.txt and the word "shells" appears in file 2.txt and the user wants to find all the text files that contain sea or shells the user can type a query "sea or shells " and obtain the results as 1.txt,  
2.txt
3) The application supports the logical precedence of operators - "not, and, or" in that order. The precedence of the operators can be changed by using parenthesis.

Indexing:

Indexing is done by InvertedIndex.java Its function is to build an index. An index maps terms to the documents where they are present. The program takes two arguments, first argument is the path to 
directory that contains the input files that needs to be indexed and the second the path to the output directory where the results of the program (index file and document index file) is stored.

The logic for indexing works as follows:
1) Read all the file names in the directory and sub directories and create a Document Index. The document index consists of the Document Id as key (doc counter) and the name of the document as the value. 
The doc index is stored in a JSON format - {"docIndex":{"1":"1.txt","2":"2.txt","3":"3.txt"}}

2) Read all the terms (each term is a word separated by a space) in each document and create a mapping of a word (key) and value which is the document ids where the term occurs. The index is stored as a 
JSON format - 
{"index":{"over":[1],"but":[3],"some":[3],"quick":[1],"betty":[3],"butter":[3],"sells":[2],"shells":[2],"lazy":[1],"bought":[3],"more":[3],"shore":[2],"was":[3],"jumps":[1],"brown":[1],"bitter":[
3],"fox":[1],"sea":[2],"the":[1,2,3],"better":[3],"she":[2],"so":[3],"dog":[1,2],"on":[2]}}


Querying:

Querying is done by first parsing the query. For example if the query is find all documents that has "dog and not fox" the program then decides the precedence of operations by applying this rule - NOT, 
AND, OR. Since "not" comes first in precedence the program forms a list of all document names that does not have "fox" in it.  The program then evaluates the expression and gets all documents has the 
word "dog". The the program performs a list intersection between the two lists to take care of the "and" operator. So if 2.txt and 3.txt does not have fox and 1.txt and 2.txt has dog in it the 
intersection of both the lists is 2.txt and so 2.txt has "dog" but does not have "fox" in it.


UI:

The UI is written using Java Swing. It contains the following methods, Build the JFrame representing the layout for the boolean search application, Process user click on search button, Display the header 
image,  Create the GUI and show it. The UI displays the 3 text files that was used to build the index. The index can be built using any number of documents. For illustrative purposes I have used 3 
documents so the user can type queries and verify if the results are accurate. 
Below are a few sample queries:

dog
dog or sea
dog and not fox
not dog
(quick and fox) or (butter and bitter)
(quick or sea) and dog
quick or sea and dog

What I learned?

This project taught me fundamentals of how a search engine is written. Now I am able to appreciate the power of using files to store indexes and convert contents of a file into maps and use data structures 
like maps and lists to process search queries. 	There are two main classes which do most of the work - Query.java - https://github.com/anuvabanwasi/apcompsci/blob/master/noogly/src/org/noogly/query/
Query.java  and InvertedIndex.java - https://github.com/anuvabanwasi/apcompsci/blob/master/noogly/src/org/noogly/index/InvertedIndex.java. The InvertedIndex.java is written so that it can read all files
inside a directory. It can also traverse the subdirectories in the main directory and read all the files in them as well and create the Document Index and the main Index. In the first iteration of Query.java 
I was not sure how to process more sophisticated queries using paranthesis. Then I realized I could start treating paranthesis as an operator and apply similar rules of operation as I would for and, or, not. One of the most critical part of Query.java uses the Stack data structure. I use one stack for the terms and one stack for the operators (or, not, and, left paren, right paren). This project taught me me how to use the Stack data structure to keep track of the terms and the operators and apply them together to find the results of a query (Reference: http://www.geeksforgeeks.org/expression-evaluation/). After the 
results are found I then apply intersection (if the operator is "and") and union (if the operator is "or") of lists. The project taught me when I should use list.add and when to use list.addAll.

Future Scope for Enhancements:

1) Removing stop words - Common words like the, for, was, is, has,...must be ignored while performing searches since users normally are not looking for documents that has the most common words like the ones
listed here: https://www.ranks.nl/stopwords
2) Spell correction - If user enters common spelling errors the application must detect those and apply spell correction
3) Compression - If there are millions of files to be processed for indexing (like what happens in regular search engines) then the index must be stored in a compressed format so it does not cause index 
bloat
4) Suggestions - As the user is typing give the user a list of suggested queries based on what other users query for


Project References:

https://libguides.mit.edu/c.php?g=175963&p=1158594
http://logic.stanford.edu/intrologic/secondary/notes/chapter_01.html
http://booleanblackbelt.com/2008/12/basic-boolean-search-operators-and-query-modifiers-explained/
http://www.htmlbasictutor.ca/search-engine-indexing.htm

Code References (documented in the code):

https://www.mkyong.com/java/how-to-write-to-file-in-java-bufferedwriter-example/
https://www.mkyong.com/java/how-to-traverse-a-directory-structure-in-java/
https://www.mkyong.com/java/how-to-read-file-from-java-bufferedreader-example/
http://www.geeksforgeeks.org/expression-evaluation/